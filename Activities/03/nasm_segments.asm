;;; rchaney@pdx.edu
;;; display the addresses of the segments/sections in a UNIX process
;;; using nasm to display the addresses
;;; this is an analog to a C program that shows the same set of segments/sections
;;; it takes a LOT more lines of code to do this in assembler

;;; compile with:
;;; nasm -g -f elf32 -F dwarf -l nasm_segments.lst nasm_segments.asm
;;; gcc -m32 -no-pie -fno-pie -o nasm_segments nasm_segments.o

;;; the addresses generated by this code dont exactly line up with the output
;;; in the nasm lst file.

;; we need to tell the compiler that references to these symbols will be
;; resolved at link time, we promise...
extern  printf              ; a C function, to be called
extern  malloc              ; a C function, to be called

;; this declaration must occur before the the definition of the symbol.
;; it means that the symbol (entry point) will be defined within this
;; module.
global main             ; the standard C entry point for our program
;;global xx
;;global yy
;;global zz

    ;; Some preprocessor directives. these are like #define preprocessor directives
    ;; in a C program. It allows us to use something that is easier to understand
    ;; than just putting numbers in our code.
    %define TAB 9           ; The decimal value for the ASCII tab-character
    %define NL  10          ; The decimal value for the ASCII newline-character
    %define NULL 0          ; The C string terminator (a NULL pointer)
    %define EXIT_SUCCESS 0  ; Easier to use than boring numbers

section .bss                ; Data segment BSS, uninitialized variables
    xx: resd 1              ; Reserve a single 4 byte variable in the bss

section .data               ; Data segment, initialized variables
    yy: dd 7                ; Allocate 4 bytes and initialize to 7
    bb: dd NULL             ; Allocate 4 bytes and initialize to NULL (which is 0)

    ;; any variables/memory in this segment should not be modifiable.
    ;; the C compiler will catch us it try to change a const variable and not
    ;; compile our program.
section .rodata
    zz: dd 0x0              ; The read only variable. This cannot be chnaged.

    ;; all the various format statements we use with printf
    ;; use of the macros makes this a bit easier to understand
    ;; these are all read-only
    fmt_header: db "identifier", TAB, TAB, "abs address", TAB, "relative address", NL, NULL
    fmt_stack:  db "stack &aa:", TAB, TAB, "%11p", TAB, "%#010x", NL, NULL
    fmt_heap:   db "heap bb:", TAB, TAB, "%11p", TAB, "%#010x", NL, NULL
    fmt_bss:    db "uninitialized &xx:", TAB, "%11p", TAB, "%#010x", NL, NULL
    fmt_data:   db "initialized &yy:", TAB, "%11p", TAB, "%#010x", NL, NULL
    fmt_ro:     db "read-only &zz:", TAB, TAB, "%11p", TAB, "%#010x", NL, NULL
    fmt_text:   db "text &main:", TAB, TAB, "%11p", TAB, "0x%08u", NL, NULL

section .text               ; text/code segment follows

main:                       ; the program label for the entry point
    push ebp                ; set up stack frame
    mov  ebp, esp

    push dword fmt_header   ; push the format string onto the stack
    call printf             ; call the printf function
    add  esp, 4             ; clean up the stack
    
    ;; printing the value of the beginning of the stack. we don't need to
    ;; have a variable for this, we can just use the esp register.
    ;; in the C version, we created a variable called aa on the stack in main()
    ;; and used that as the high address of the stack. we __could__ create a
    ;; variable called aa for this, but we really don't need to.
    mov  eax, esp           ; so we can do some math on the stack address
    sub  eax, main          ; subtract the address of main from the address of the stack
    push dword eax          ; push the first of 3 parameters to printf
    push dword esp          ; this is the address of the stack
    push dword fmt_stack    ; the format string for printf
    call printf
    add  esp, 12            ; clean up the stack from the call to printf

    ;; allocate some space from the heap then print the returned address
    push 8                  ; we want to allocate 8 bytes (1 ints)
    call malloc             ; call malloc. the address of the memory is returned in eax
    mov  [bb], eax          ; store the address returned from malloc in bb
    ;; mov   eax, [bb]      ;; the value is already in eax
    sub  eax, main          ; subtract the address of main from the value returned from malloc
    push dword eax
    push dword [bb]         ; push the address in bb onto the stack for printf
    push dword fmt_heap
    call printf
    add  esp, 12

    ;; the uninitialized data section (the bss)
    mov  eax, xx
    sub  eax, main
    push dword eax
    push dword xx           ; the variable we allowcated in the UNinitialized section
    push dword fmt_bss
    call printf
    add  esp, 12

    ;; the initialized data section
    mov  eax, yy
    sub  eax, main
    push dword eax
    push dword yy           ; the variable we declared and initialized data section
    push dword fmt_data
    call printf
    add  esp, 12

    ;; the read-only data section
    mov  eax, zz            ; the variable in the .rodata section
    sub  eax, main
    push dword eax
    push dword zz           ; the variable we declared above in the .rodata section
    push dword fmt_ro
    call printf
    add  esp, 12

    ;; the text/code section
    ;; the function main() is often given an address of 0 in diagrams of the
    ;; address space for a process.
    mov  eax, main
    sub  eax, main          ; yes, i know this is zero. i just want to follow the pattern.
    push dword eax
    push dword main         ; our program entry point.
    push dword fmt_text
    call printf
    add  esp, 12

    mov  esp, ebp           ; takedown stack frame
    pop  ebp

    mov  eax, EXIT_SUCCESS  ; normal, no error, return value
    ret                     ; return
