     1                                  ;;; rchaney@pdx.edu
     2                                  ;;; display the addresses of the segments/sections in a UNIX process
     3                                  ;;; using nasm to display the addresses
     4                                  ;;; this is an analog to a C program that shows the same set of segments/sections
     5                                  ;;; it takes a LOT more lines of code to do this in assembler
     6                                  
     7                                  ;;; compile with:
     8                                  ;;; nasm -g -f elf32 -F dwarf -l nasm_segments.lst nasm_segments.asm
     9                                  ;;; gcc -m32 -no-pie -fno-pie -o nasm_segments nasm_segments.o
    10                                  
    11                                  ;;; the addresses generated by this code dont exactly line up with the output
    12                                  ;;; in the nasm lst file.
    13                                  
    14                                  ;; we need to tell the compiler that references to these symbols will be
    15                                  ;; resolved at link time, we promise...
    16                                  extern  printf              ; a C function, to be called
    17                                  extern  malloc              ; a C function, to be called
    18                                  
    19                                  ;; this declaration must occur before the the definition of the symbol.
    20                                  ;; it means that the symbol (entry point) will be defined within this
    21                                  ;; module.
    22                                  global main             ; the standard C entry point for our program
    23                                  ;;global xx
    24                                  ;;global yy
    25                                  ;;global zz
    26                                  
    27                                      ;; Some preprocessor directives. these are like #define preprocessor directives
    28                                      ;; in a C program. It allows us to use something that is easier to understand
    29                                      ;; than just putting numbers in our code.
    30                                      %define TAB 9           ; The decimal value for the ASCII tab-character
    31                                      %define NL  10          ; The decimal value for the ASCII newline-character
    32                                      %define NULL 0          ; The C string terminator (a NULL pointer)
    33                                      %define EXIT_SUCCESS 0  ; Easier to use than boring numbers
    34                                  
    35                                  section .bss                ; Data segment BSS, uninitialized variables
    36 00000000 ????????                    xx: resd 1              ; Reserve a single 4 byte variable in the bss
    37                                  
    38                                  section .data               ; Data segment, initialized variables
    39 00000000 07000000                    yy: dd 7                ; Allocate 4 bytes and initialize to 7
    40 00000004 00000000                    bb: dd NULL             ; Allocate 4 bytes and initialize to NULL (which is 0)
    41                                  
    42                                      ;; any variables/memory in this segment should not be modifiable.
    43                                      ;; the C compiler will catch us it try to change a const variable and not
    44                                      ;; compile our program.
    45                                  section .rodata
    46 00000000 00000000                    zz: dd 0x0              ; The read only variable. This cannot be chnaged.
    47                                  
    48                                      ;; all the various format statements we use with printf
    49                                      ;; use of the macros makes this a bit easier to understand
    50                                      ;; these are all read-only
    51 00000004 6964656E7469666965-         fmt_header: db "identifier", TAB, TAB, "abs address", TAB, "relative address", NL, NULL
    51 0000000D 720909616273206164-
    51 00000016 64726573730972656C-
    51 0000001F 617469766520616464-
    51 00000028 726573730A00       
    52 0000002E 737461636B20266161-         fmt_stack:  db "stack &aa:", TAB, TAB, "%11p", TAB, "%#010x", NL, NULL
    52 00000037 3A0909253131700925-
    52 00000040 23303130780A00     
    53 00000047 686561702062623A09-         fmt_heap:   db "heap bb:", TAB, TAB, "%11p", TAB, "%#010x", NL, NULL
    53 00000050 092531317009252330-
    53 00000059 3130780A00         
    54 0000005E 756E696E697469616C-         fmt_bss:    db "uninitialized &xx:", TAB, "%11p", TAB, "%#010x", NL, NULL
    54 00000067 697A6564202678783A-
    54 00000070 092531317009252330-
    54 00000079 3130780A00         
    55 0000007E 696E697469616C697A-         fmt_data:   db "initialized &yy:", TAB, "%11p", TAB, "%#010x", NL, NULL
    55 00000087 6564202679793A0925-
    55 00000090 313170092523303130-
    55 00000099 780A00             
    56 0000009C 726561642D6F6E6C79-         fmt_ro:     db "read-only &zz:", TAB, TAB, "%11p", TAB, "%#010x", NL, NULL
    56 000000A5 20267A7A3A09092531-
    56 000000AE 317009252330313078-
    56 000000B7 0A00               
    57 000000B9 7465787420266D6169-         fmt_text:   db "text &main:", TAB, TAB, "%11p", TAB, "0x%08u", NL, NULL
    57 000000C2 6E3A09092531317009-
    57 000000CB 3078253038750A00   
    58                                  
    59                                  section .text               ; text/code segment follows
    60                                  
    61                                  main:                       ; the program label for the entry point
    62 00000000 55                          push ebp                ; set up stack frame
    63 00000001 89E5                        mov  ebp, esp
    64                                  
    65 00000003 68[04000000]                push dword fmt_header   ; push the format string onto the stack
    66 00000008 E8(00000000)                call printf             ; call the printf function
    67 0000000D 83C404                      add  esp, 4             ; clean up the stack
    68                                      
    69                                      ;; printing the value of the beginning of the stack. we don't need to
    70                                      ;; have a variable for this, we can just use the esp register.
    71                                      ;; in the C version, we created a variable called aa on the stack in main()
    72                                      ;; and used that as the high address of the stack. we __could__ create a
    73                                      ;; variable called aa for this, but we really don't need to.
    74 00000010 89E0                        mov  eax, esp           ; so we can do some math on the stack address
    75 00000012 2D[00000000]                sub  eax, main          ; subtract the address of main from the address of the stack
    76 00000017 50                          push dword eax          ; push the first of 3 parameters to printf
    77 00000018 54                          push dword esp          ; this is the address of the stack
    78 00000019 68[2E000000]                push dword fmt_stack    ; the format string for printf
    79 0000001E E8(00000000)                call printf
    80 00000023 83C40C                      add  esp, 12            ; clean up the stack from the call to printf
    81                                  
    82                                      ;; allocate some space from the heap then print the returned address
    83 00000026 6A08                        push 8                  ; we want to allocate 8 bytes (1 ints)
    84 00000028 E8(00000000)                call malloc             ; call malloc. the address of the memory is returned in eax
    85 0000002D A3[04000000]                mov  [bb], eax          ; store the address returned from malloc in bb
    86                                      ;; mov   eax, [bb]      ;; the value is already in eax
    87 00000032 2D[00000000]                sub  eax, main          ; subtract the address of main from the value returned from malloc
    88 00000037 50                          push dword eax
    89 00000038 FF35[04000000]              push dword [bb]         ; push the address in bb onto the stack for printf
    90 0000003E 68[47000000]                push dword fmt_heap
    91 00000043 E8(00000000)                call printf
    92 00000048 83C40C                      add  esp, 12
    93                                  
    94                                      ;; the uninitialized data section (the bss)
    95 0000004B B8[00000000]                mov  eax, xx
    96 00000050 2D[00000000]                sub  eax, main
    97 00000055 50                          push dword eax
    98 00000056 68[00000000]                push dword xx           ; the variable we allowcated in the UNinitialized section
    99 0000005B 68[5E000000]                push dword fmt_bss
   100 00000060 E8(00000000)                call printf
   101 00000065 83C40C                      add  esp, 12
   102                                  
   103                                      ;; the initialized data section
   104 00000068 B8[00000000]                mov  eax, yy
   105 0000006D 2D[00000000]                sub  eax, main
   106 00000072 50                          push dword eax
   107 00000073 68[00000000]                push dword yy           ; the variable we declared and initialized data section
   108 00000078 68[7E000000]                push dword fmt_data
   109 0000007D E8(00000000)                call printf
   110 00000082 83C40C                      add  esp, 12
   111                                  
   112                                      ;; the read-only data section
   113 00000085 B8[00000000]                mov  eax, zz            ; the variable in the .rodata section
   114 0000008A 2D[00000000]                sub  eax, main
   115 0000008F 50                          push dword eax
   116 00000090 68[00000000]                push dword zz           ; the variable we declared above in the .rodata section
   117 00000095 68[9C000000]                push dword fmt_ro
   118 0000009A E8(00000000)                call printf
   119 0000009F 83C40C                      add  esp, 12
   120                                  
   121                                      ;; the text/code section
   122                                      ;; the function main() is often given an address of 0 in diagrams of the
   123                                      ;; address space for a process.
   124 000000A2 B8[00000000]                mov  eax, main
   125 000000A7 2D[00000000]                sub  eax, main          ; yes, i know this is zero. i just want to follow the pattern.
   126 000000AC 50                          push dword eax
   127 000000AD 68[00000000]                push dword main         ; our program entry point.
   128 000000B2 68[B9000000]                push dword fmt_text
   129 000000B7 E8(00000000)                call printf
   130 000000BC 83C40C                      add  esp, 12
   131                                  
   132 000000BF 89EC                        mov  esp, ebp           ; takedown stack frame
   133 000000C1 5D                          pop  ebp
   134                                  
   135 000000C2 B800000000                  mov  eax, EXIT_SUCCESS  ; normal, no error, return value
   136 000000C7 C3                          ret                     ; return
